import logging
import time
from decimal import Decimal
from typing import Union

from defabipedia import Chain
from defabipedia.tokens import EthereumTokenAddr
from karpatkit.node import get_node
from web3 import Web3

from defyes.functions import balance_of

from .autogenerated import CdpManager, DsrManager, IlkRegistry, McdSpot, Pot, ProxyRegistry, Vat

logger = logging.getLogger(__name__)


class ProxyRegistry(ProxyRegistry):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4",
    }


class CdpManager(CdpManager):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x5ef30b9986345249bc32d8928B7ee64DE9435E39",
    }

    def get_vault_ids(self, proxy_addr: str) -> list[int]:
        ids = []
        n_id = self.first(proxy_addr)
        for nvault in range(self.count(proxy_addr)):
            ids.append(n_id)
            n_id = self._list(n_id)[1]
        return ids


class IlkRegistry(IlkRegistry):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x5a464C28D19848f44199D003BeF5ecc87d090F87",
    }


class Vat(Vat):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
    }


class McdSpot(McdSpot):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3",
    }


class Pot(Pot):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
    }

    @property
    def chi(self):
        if time.time() > self.rho:
            chi = self.drip
        else:
            chi = self.chi
        return chi


class DsrManager(DsrManager):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0x373238337Bfe1146fb49989fc222523f83081dDb",
    }


def get_vault_data(vault_id: int, block: int | str) -> list:
    cdp_manager = CdpManager(Chain.ETHEREUM, block)
    ilk_registry = IlkRegistry(Chain.ETHEREUM, block)
    vat = Vat(Chain.ETHEREUM, block)
    spot = McdSpot(Chain.ETHEREUM, block)

    ilk = cdp_manager.ilks(vault_id)
    ilk_info = ilk_registry.info(ilk)
    urn_handler_address = cdp_manager.urns(vault_id)
    urn_data = vat.urns(ilk, urn_handler_address)
    ilk_data = vat.ilks(ilk)

    vault_data = {
        "mat": spot.ilks(ilk)[1] / Decimal(10**27),
        "gem": ilk_info[4],
        "dai": EthereumTokenAddr.DAI,
        "ink": urn_data[0] / Decimal(10**18),
        "art": urn_data[1] / Decimal(10**18),
        "Art": ilk_data[0] / Decimal(10**18),
        "rate": ilk_data[1] / Decimal(10**27),
        "spot": ilk_data[2] / Decimal(10**27),
        "line": ilk_data[3] / Decimal(10**45),
        "dust": ilk_data[4] / Decimal(10**45),
    }

    return vault_data


def underlying(vault_id: int, block: int | str) -> tuple[list]:
    """
    Output:
    1 - Tuple: [[collateral_address, collateral_amount], [debt_address, -debt_amount]]
    """
    result = []

    vault_data = get_vault_data(vault_id, block)

    # Append the Collateral Address and Balance to result[]
    result.append([vault_data["gem"], vault_data["ink"]])

    # Append the Debt Address (DAI Address) and Balance to result[]
    total_debt = (vault_data["art"] * vault_data["rate"]) * -1
    result.append([vault_data["dai"], total_debt])

    return result


def get_delegated_MKR(wallet: str, block: Union[int, str], web3=None, decimals=True) -> Union[int, float]:
    if web3 is None:
        web3 = get_node(Chain.ETHEREUM)

    IOU_token_address = "0xA618E54de493ec29432EbD2CA7f14eFbF6Ac17F7"
    balance = balance_of(wallet, IOU_token_address, block, Chain.ETHEREUM, web3=web3, decimals=decimals)
    return [[EthereumTokenAddr.MKR, balance]]


def get_protocol_data(blockchain: str, wallet: str, block: int | str = "latest", decimals: bool = True) -> dict:
    """
    TODO: Add documentation
    """
    wallet = Web3.to_checksum_address(wallet)
    positions = {}

    proxy = ProxyRegistry(blockchain, block)
    cdp = CdpManager(blockchain, block)
    ilk_registry = IlkRegistry(blockchain, block)
    vat = Vat(blockchain, block)
    dsr = DsrManager(blockchain, block)
    pot = Pot(blockchain, block)

    proxy_addr = proxy.proxies(wallet)
    vault_ids = cdp.get_vault_ids(proxy_addr)
    for vault_id in vault_ids:
        positions["vaults"] = positions.get("vaults", {})
        ilk = cdp.ilks(vault_id)
        ilk_info = ilk_registry.info(ilk)
        urn_handler_address = cdp.urns(vault_id)
        urn_data = vat.urns(ilk, urn_handler_address)
        ilk_data = vat.ilks(ilk)

        gem = ilk_info[4]
        ink = urn_data[0] / Decimal(10**18 if decimals else 1)
        art = urn_data[1] / Decimal(10**18)
        rate = ilk_data[1] / Decimal(10**27)

        positions["vaults"][vault_id] = {
            "liquidity": {
                "underlyings": [
                    {"address": gem, "balance": ink},
                    {
                        "address": EthereumTokenAddr.DAI,
                        "balance": -1 * art * rate * Decimal(1 if decimals else 10**18),
                    },
                ]
            }
        }

    dsr_balance = Decimal(dsr.pie_of(wallet) * pot.chi) / Decimal(1e18) / Decimal(1e27)
    positions["mananger"] = {
        "liquidity": {
            "underlyings": [
                {"address": EthereumTokenAddr.DAI, "balance": dsr_balance * Decimal(1 if decimals else 10**18)},
            ]
        }
    }

    pot_balance = Decimal(pot.pie_1(wallet) * pot.chi) / Decimal(1e18) / Decimal(1e27)
    positions["pot"] = {
        "liquidity": {
            "underlyings": [
                {"address": EthereumTokenAddr.DAI, "balance": pot_balance * Decimal(1 if decimals else 10**18)},
            ]
        }
    }
    return {
        "protocol": "Maker",
        "blockchain": blockchain,
        "wallet": Web3.to_checksum_address(wallet),
        "block_id": block,
        "positions_key": None,
        "positions": positions,
        "version": 0,
    }
