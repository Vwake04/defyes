import json
import logging
from decimal import Decimal
from pathlib import Path

import requests
from karpatkit.constants import Address
from web3 import Web3

from defyes.functions import ensure_a_block_number
from defyes.types import Addr, Token, TokenAmount

from .autogenerated import LiquidityPool, LiquidityPoolToken

logger = logging.getLogger(__name__)

DB_VERSION = "v0.0.190"
DB_FILENAME = "db_addrs.json"


def update_db(filename=DB_FILENAME):
    url = f"https://github.com/hop-protocol/hop/raw/{DB_VERSION}/packages/core/src/addresses/mainnet.ts"
    response = requests.get(url)
    if response.status_code == 200:
        processed_lines = []
        for line in response.text.split("\n"):
            p_line = line.split("//")[0].rstrip().replace("'", '"')
            if ":" in p_line:
                key, data = p_line.split(":")
                key = key.split(":")[0].split(" ")
                p_line = " ".join(key[:-1]) + f'"{key[-1]}":' + data
            processed_lines.append(p_line)
        add_version = f'{{\n  "version": "{DB_VERSION}",\n'
        json_object = json.loads(add_version + "\n".join(processed_lines[3::]))

        with open(Path(__file__).parent / filename, "w") as outfile:
            json.dump(json_object, outfile, indent=2, default=lambda o: str(o))
    else:
        logger.debug("Failed to retrieve db. Status code: %s", response.status_code)


def get_lptokens_from_db(db_file=DB_FILENAME):
    with open(Path(__file__).parent / db_file, "r") as infile:
        data = json.load(infile)
    lp_tokens = {}
    for token, info in data["bridges"].items():
        for blockchain, addrs in info.items():
            for key, addr in addrs.items():
                if "LpToken" in key and addr != Address.ZERO:
                    lp_tokens[blockchain] = lp_tokens.get(blockchain, [])
                    lp_tokens[blockchain].append({"token": token, "addr": addr})

    return lp_tokens


def get_rewards_contracts_from_db(db_file=DB_FILENAME):
    with open(Path(__file__).parent / db_file, "r") as infile:
        data = json.load(infile)["rewardsContracts"]
    rewards = {}
    for token, info in data.items():
        for blockchain, addrs in info.items():
            rewards[blockchain] = rewards.get(blockchain, {})
            rewards[blockchain][token] = addrs
    return rewards


def get_protocol_data_for(
    blockchain: str,
    wallet: str,
    lptoken_address: str | list,
    block: int | str = "latest",
    decimals: bool = True,
) -> dict:
    wallet = Addr(Web3.to_checksum_address(wallet))
    block_id = ensure_a_block_number(block, blockchain)
    ret = {
        "blockchain": blockchain,
        "block_id": block_id,
        "protocol": "Hop AMM",
        "version": 0,
        "wallet": wallet,
        "positions": {},
        "positions_key": "lptoken_address",
    }

    if isinstance(lptoken_address, str):
        lptoken_address = [lptoken_address]

    possible_lp_tokens = get_lptokens_from_db()
    for lptoken_addr in lptoken_address:
        lptoken_addr = Addr(Web3.to_checksum_address(lptoken_addr))
        position = {}

        token = None
        for lptoken in possible_lp_tokens[blockchain]:
            if lptoken["addr"] == lptoken_addr:
                token = lptoken["token"]

        if token is None:
            raise ValueError(f"Wrong lptoken provided ({lptoken_addr}) for {blockchain}")

        lpt = LiquidityPoolToken(blockchain, block_id, lptoken_addr)
        balance = lpt.balance_of(wallet)
        if balance:
            lp = LiquidityPool(blockchain, block_id, lpt.swap)
            underlying_balances = lp.calculate_remove_liquidity(wallet, balance)
            underlying_amounts = []
            for n, underlying in enumerate(underlying_balances):
                t = Token.get_instance(lp.get_token(n), blockchain, block_id)
                underlying_amounts.append(TokenAmount.from_teu(underlying, t))
            position = {
                "liquidity": {
                    "holdings": [
                        {"address": lptoken_addr, "balance": balance / Decimal(10**lpt.decimals if decimals else 1)}
                    ],
                    "underlyings": [amount.as_dict(decimals) for amount in underlying_amounts],
                }
            }

        # reward_contracts = get_rewards_contracts_from_db()[blockchain][token]
        if position:
            ret["positions"][lptoken_addr] = position
        return ret
